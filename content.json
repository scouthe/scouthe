{"pages":[],"posts":[{"title":"markdown_learning","text":"abstractmarkdown learning recording 一级二级三级四级五级h1h2h3h4h5这是一级标题这是二级标题 这段文字高亮显示 点击跳转百度 图片比链接引用多一个感叹号 无序列表 *黄瓜*玉米*茄子 +黄瓜+玉米+茄子 -黄瓜-玉米-茄子 有序列表 1.黄瓜2.玉米3.茄子 段落一 小段一 段落二 小段二 段落一 区块标记一 区块二 三 段落二 区块标记二 这是斜体这是斜体 加粗加粗粗斜删除 下划线 脚注这是一个脚注示例 [^abc]。[^abc]: 这是脚注。 高级用法插入代码块print()函数 var x = 3 123$(document).ready(function () { alert('RUNOOB');}); 123 fun (x: Int, y: Int): Int { return x + y} 表头 条目 条目二 项目 项目一 项目二 注：三个短斜杠左右的冒号用于控制对齐方式，只放置左边冒号表示文字居左，只放置右边冒号表示文字居右，如果两边都放置冒号表示文字居中。 #其他##特殊符号处理 \\用来插入特殊符号 /#\\ TestTest","link":"/2021/08/16/markdown_learning/"},{"title":"hexo_auto","text":"Abstracthexo blog auto new blog and publish blog hexo auto new blog using hexo scaffold for example new a .bat file and put this code code1234567@echo off set /p a= input title:echo title:%a%call hexo new post &quot;%a%&quot;cd .\\source\\_posts\\Start %a%.mdpause hexo auto pushnew a .bat file and put this code code12call hexo d -gpause 参考文章:参考链接","link":"/2021/08/16/hexo-auto/"},{"title":"VPN-v2ray establish on your own VPS","text":"abstractThis artical will give you an simple way to bulid your own VPN preparation A domain name A VPS An acount of the Cloudflare with the free plan is enough A software XSHELL to connect your VPS 1.Connect your server by XSHELL 2.Log in the clondflare and DNS your domain name to your server ipAfter DNS, don’t light the yellow cloudMake sure your domain name’s DNS server is under the cloudflare. 3.run command1bash &lt;(curl -s -L https://git.io/v2ray.sh) choose 1 to install choose 4 to select transport protocols entere your domain name(second-level domain also useful) then y TLS “y” the rest just press enter wait for the install finish Back to cloudflare to light the yellow cloud 4.get the vmess linkrun v2ray linkcopy the link to add in the v2rayN 5.manager the v2rayv2ray infov2ray configv2ray link generate V2Ray linkv2ray infolink generate V2Ray info linkv2ray qr v2ray generate QR codev2ray ss edit Shadowsocks infov2ray ssinfo check the Shadowsocks infov2ray ssqr generate Shadowsocks QR codev2ray statusv2ray start v2ray stop v2ray restart v2ray logv2ray update v2ray update.sh v2ray uninstall refer link","link":"/2021/08/21/VPN-v2ray-establish-on-your-own-VPS/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/08/22/hello-world/"},{"title":"Playwright,微软浏览器自动化教程（二）","text":"Playwright,微软浏览器自动化教程（二）核心概念，建议结合第一节的内容具体理解 1、Browser这是一个浏览器实例，脚本运行需要首先打开浏览器实例 12# playwright.brwoser_type.action(**kwargs)可以理解为指定浏览器内核browser = playwright.chromium.launch(channel=&quot;chrome&quot;,headless=False) 123456# launch是最常用的一个函数，他有大量的参数,这里介绍常用的的headless 是否显示GUI，默认是TRUE不显示channel 指定浏览器版本，&quot;chrome&quot;, &quot;chrome-beta&quot;, &quot;chrome-dev&quot;, &quot;chrome-canary&quot;,proxy 浏览器代理设置timeout 等待超时时间，默认30000ms（30s）slow_mo 减慢操作速度，浮点型，一边可以看清楚操作 顺便说一下，playwright的所有操作都有自动等待的功能，时间都是30s 2、Browser contexts这个是独立的浏览器，隐身对话，意思是每一个Beowser contexts都是独立的，互相之间没有关系，等于说全都是新装的浏览器。 1234# 根据浏览器内核创建浏览器context = browser.new_context(accept_downloads=False)# 创建新页面page = context.new_page() 2.1、browser.new_context1234567# browser.new_context的参数包括所有跟浏览器设置相关的# 可以理解为根据浏览器创建一个新的浏览器accept_downloads 是否下载所有附件，默认False不下载geolocation 设定经纬度user_agent 设定user agentviewport 设定页面大小，规格，例如1280*720offline 离线模式加载 2.2、context123456# context就是浏览器层面的操作context.new_page() 返回一个新页面context.pages 返回所有打开的页面[list]context.add_cookies([cookie_object1, cookie_object2]) 添加cookiecontext.cookies() 返回cookiecontext.wait_for_event(event, **kwargs) 等待event完成 3、Pages and frames一个 Browser contexts 有多个pages，一个 page 是一个单独的tab，或者弹出窗口。用于导航到url ，或者与页面交互，比如点击，输入文字等。一个 page 有多个 Frame （框架），框架内的操作无法通过page.**操作，只能通过page.Frame.func（）操作，但是通常在录制模式下，他会自动识别是否是框架内的操作，如果不懂怎么定位框架，那么可以使用录制模式来找。 3.1、Pages大部分操作都是在page层面的，所以page有最多的函数 12345678910111213from playwright.sync_api import sync_playwright# 这是一个创建页面，定位到指定链接，并截屏保存的例子def run(playwright): webkit = playwright.webkit browser = webkit.launch() context = browser.new_context() page = context.new_page() page.goto(&quot;https://example.com&quot;) page.screenshot(path=&quot;screenshot.png&quot;) browser.close()with sync_playwright() as playwright: run(playwright) 常用的函数有，一般看名字就知道是干嘛的 1234567891011121314151617181920212223242526page.click(selector, **kwargs)page.content() # 获取页面的htmlpage.screenshot(**kwargs)page.goto(url, **kwargs)page.pdf(**kwargs)page.reload(**kwargs)page.wait_for_timeout(timeout)page.get_attribute(selector, name, **kwargs)# page的expect_**函数需要注意# 这个类型的函数一般都伴随这with使用# 下面这个例子就是点击按钮后，改变了页面框架with page.expect_event(&quot;framenavigated&quot;) as event_info: page.click(&quot;button&quot;)frame = event_info.value#这样的还有很多，比如，大都用在交互的对象改变的情况下page.expect_file_chooser(**kwargs)page.expect_navigation(**kwargs)page.expect_popup(**kwargs)# 个人推荐注意这几个is的方法，在等待页面的时候很有用page.is_disabled/(selector, **kwargs)is_editable，is_enabled，is_hidden，is_visible# 还有一个特殊的方法page.locator(selector) # 定位页面元素，返回的是locator对象 3.2、Frameframe的操作大部分跟page一样，只不过frame是page下一级的，可以理解为在page里嵌套的一个小页面。但是还是有一点不一样。page里分为主框架和子框架，这里有一个框架树的例子,大家可以运行下试试。 1234567891011121314151617from playwright.sync_api import sync_playwrightdef run(playwright): firefox = playwright.firefox browser = firefox.launch() page = browser.new_page() page.goto(&quot;https://www.theverge.com&quot;) dump_frame_tree(page.main_frame, &quot;&quot;) browser.close()def dump_frame_tree(frame, indent): print(indent + frame.name + '@' + frame.url) for child in frame.child_frames: dump_frame_tree(child, indent + &quot; &quot;)with sync_playwright() as playwright: run(playwright) 其方法大部分都与page一样，不在赘述，注意的是page.frame(**kwargs)，这个可以用来选择Frame，并返回Frame对象，所以对Frame的操作有一下两种方法。 123456# 直接定位Frame操作page.frame(name=&quot;frame-name&quot;).click('text=hello')#返回Frame对象操作frame = page.frame(name=&quot;frame-name&quot;)frame.click('text=hello') 4、SelectorsPlaywright可以通过css,XPath,HTML等选择元素，像id,data-test-id，或者像上面演示的，通过text内容。这里有一些例子 12345678910111213# Using data-test-id= selector enginepage.click('data-test-id=foo')# CSS and XPath selector engines are automatically detectedpage.click('div')page.click('//html/body/div')# Find node by text substringpage.click('text=Hello w')# 通过 &gt;&gt; 链接相同或不同的选择器# Click an element with text 'Sign Up' inside of a #free-month-promo.page.click('#free-month-promo &gt;&gt; text=Sign Up') 我推荐使用浏览器的开发者模式来寻找选择器： 5、Auto-waiting所有的操作都会等待元素可见，或者可操作之后才会进行，也就是自带等待时间，但是如果要自己加等待的话不推荐使用time.sleep(5)，而是用page.wait_for_timeout(5000)。这里也可以使用page的wait操作: 123456page.wait_for_event(event, **kwargs)page.wait_for_function(expression, **kwargs)page.wait_for_load_state(**kwargs)page.wait_for_selector(selector, **kwargs)page.wait_for_timeout(timeout)page.wait_for_url(url, **kwargs) 6、Evaluation Argument像 page.evaluate(expression, **kwargs) 这样的剧作家评估方法采用单个可选参数。 此参数可以是 Serializable 值和 JSHandle 或 ElementHandle 实例的混合。 句柄会自动转换为它们所代表的值。 123456789101112131415161718192021222324252627282930313233343536373839# A primitive value.page.evaluate('num =&gt; num', 42)# An array.page.evaluate('array =&gt; array.length', [1, 2, 3])# An object.page.evaluate('object =&gt; object.foo', { 'foo': 'bar' })# A single handle.button = page.query_selector('button')page.evaluate('button =&gt; button.textContent', button)# Alternative notation using elementHandle.evaluate.button.evaluate('(button, from) =&gt; button.textContent.substring(from)', 5)# Object with multiple handles.button1 = page.query_selector('.button1')button2 = page.query_selector('.button2')page.evaluate(&quot;&quot;&quot;o =&gt; o.button1.textContent + o.button2.textContent&quot;&quot;&quot;, { 'button1': button1, 'button2': button2 })# Object destructuring works. Note that property names must match# between the destructured object and the argument.# Also note the required parenthesis.page.evaluate(&quot;&quot;&quot; ({ button1, button2 }) =&gt; button1.textContent + button2.textContent&quot;&quot;&quot;, { 'button1': button1, 'button2': button2 })# Array works as well. Arbitrary names can be used for destructuring.# Note the required parenthesis.page.evaluate(&quot;&quot;&quot; ([b1, b2]) =&gt; b1.textContent + b2.textContent&quot;&quot;&quot;, [button1, button2])# Any non-cyclic mix of serializables and handles works.page.evaluate(&quot;&quot;&quot; x =&gt; x.button1.textContent + x.list[0].textContent + String(x.foo)&quot;&quot;&quot;, { 'button1': button1, 'list': [button2], 'foo': None }) 参考文章:参考链接","link":"/2021/09/01/Playwright-%E5%BE%AE%E8%BD%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E5%8C%96%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"Playwright,微软浏览器自动化教程（一）","text":"Playwright,微软浏览器自动化教程（一）快速开始 1、简介Playwright 支持大部分的语言，Node.js, python, Java, .Net, 并且支持谷歌，火狐等浏览器，跨平台，并且支持移动端的模拟，可以很方便的录制脚本。并且可以使用同步或异步的打开方式。我们先从同步开始。 2、快速开始2.1、安装PIP123pip install --upgrade pippip install playwrightplaywright install 2.2、录制脚本推荐新手首先使用提供的录制功能，自己录制一个脚本，然后对着生成的代码，这样会对这个的使用流程有一个大概的理解。使用下面的命令可以快速录制一个脚本。 1playwright codegen wikipedia.org 123456-o &lt;file name&gt; 保存的文件名--target &lt;language&gt; 生成的脚本语言，像javascript, python(默认) -b 指定浏览器 chromium（默认）, firefox--channel &lt;channel&gt; 指定浏览器版本&quot;chrome&quot;,&quot;chrome-beta&quot;, &quot;msedge-dev&quot;--device &lt;deviceName&gt; 模拟设备，像 &quot;iPhone 11&quot; -h, --help 更多命令，请看帮助 3、脚本详解我们先从一个简单录制的脚本讲起，在生成脚本的同时，还自动生成了注释，可以说是非常方便，根据注释也可以帮助我们理解代码 123456789101112131415161718192021222324252627282930from playwright.sync_api import Playwright, sync_playwrightdef run(playwright: Playwright) -&gt; None: # 首先实例化一个浏览器对象 browser = playwright.chromium.launch(headless=False) # 打开一个浏览器会话 context = browser.new_context() # 打开一个新页面 page = context.new_page() # Go to https://www.google.com.hk/?gws_rd=ssl page.goto(&quot;https://www.google.com.hk/?gws_rd=ssl&quot;) # Click [aria-label=&quot;搜索&quot;] page.click(&quot;[aria-label=\\&quot;搜索\\&quot;]&quot;) # Fill [aria-label=&quot;搜索&quot;] page.fill(&quot;[aria-label=\\&quot;搜索\\&quot;]&quot;, &quot;playwright&quot;) # Press Enter # 这里是一个页面导航功能 # 点击元素可以出发导航，要求使用 page.expect_navigation(**kwargs) # 这里点击了搜索按钮，这样页面信息可以获取浏览器新的内容 with page.expect_navigation(): page.press(&quot;[aria-label=\\&quot;搜索\\&quot;]&quot;, &quot;Enter&quot;) # 这里由于打开了新的页面，所以需要使用page.expect_popup()来获取新的页面，并且用as来操作新的页面 with page.expect_popup() as popup_info: page.click(&quot;text=Playwright: Fast and reliable end-to-end testing for modern ...&quot;) # 这里将新页面命名为page1，并将新的页面信息传给page1 page1 = popup_info.value # 关闭浏览器会话，和浏览器 context.close() browser.close()with sync_playwright() as playwright: run(playwright) 4、总结目前来看，这个录制功能是比较方便好用的，可以帮助我们快速理解代码但是缺点也很明显，这个录制功能无法进行循环操作，仅这一条就说明无法靠录制解决所有的自动化任务，除非你选择在外层进行循环，但那样会降低效率，并且从上面代码上来看，其自动定位的元素都是text，无法从网页根本上定位元素。下一节，我将介绍playwright的核心概念，来帮助理解整个的工作流程参考文章:playwright for python","link":"/2021/09/01/Playwright-%E5%BE%AE%E8%BD%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E5%8C%96%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"Playwright+Bs4爬取微信公众号文章链接","text":"由于微信的公众号文章阅读体验过于差劲，而在找遍全网都没有找到可靠的微信rss之后，我打算自己写一个爬取微信公众号文章的脚本，结合playwright来降低爬取难度，对新手比较友好，可以不用分析请求，对我来说也是一个学习palywright的过程。 前言1、由于搜狗搜索只能看到最近十篇文章2、有找到过从网页端微信获取的，但是我的微信网页端登不上只能放弃3、还有了解过pywinauto的windows的自动化，但是已经用过playwright，还要花时间去学习4、找到有利用公众号后台的超链接进行爬取的方法因此决定使用playwright来解决这个问题 1、playwright录制脚本首先使用playwright录制脚本，将大概的过程进行录制:playwright codegen -o wehcet_fetch.py https://mp.weixin.qq.com/在录制前要想好大概的步骤，以及后面需要进行循环的翻页操作 2、设置循环由于在后台页面只要在超链接里操作就可以，所以只需要设置：1、更换公众号名字的循环2、同一个公众号文章翻页循环 通过这两步即将整个的流程处理完成了下面就是run()函数，传入的参数分别是： 12name: 公众号名字列表all_artical: 储存文章的列表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647def run(playwright: Playwright,name,all_artical) -&gt; None: browser = playwright.chromium.launch(headless=False) context = browser.new_context(accept_downloads=True) # Open new page page = context.new_page() # with page.expect_download() as download_info: # Go to https://mp.weixin.qq.com/ page.goto(&quot;https://mp.weixin.qq.com/&quot;) # Click text=图文消息 文字消息 视频消息 音频消息 图片消息 转载 &gt;&gt; svg with page.expect_popup() as popup_info: page.click(&quot;text=图文消息 文字消息 视频消息 音频消息 图片消息 转载 &gt;&gt; svg&quot;) page1 = popup_info.value # 公众号数量，用来定位all_artical num = 0 # Click text=超链接 page1.click(&quot;text=超链接&quot;) # 遍历所有名字，分别爬取 for item in name: # 保存在一个列表中的一个列表中 all_artical.append([]) # Click text=选择其他公众号 page1.click(&quot;text=选择其他公众号&quot;) # Click [placeholder=&quot;输入文章来源的公众号名称或微信号，回车进行搜索&quot;] page1.click(&quot;[placeholder=\\&quot;输入文章来源的公众号名称或微信号，回车进行搜索\\&quot;]&quot;) # Fill [placeholder=&quot;输入文章来源的公众号名称或微信号，回车进行搜索&quot;] page1.fill(&quot;[placeholder=\\&quot;输入文章来源的公众号名称或微信号，回车进行搜索\\&quot;]&quot;, item) # Click [placeholder=&quot;输入文章来源的公众号名称或微信号，回车进行搜索&quot;] page1.click(&quot;[placeholder=\\&quot;输入文章来源的公众号名称或微信号，回车进行搜索\\&quot;]&quot;) # Press Enter page1.press(&quot;[placeholder=\\&quot;输入文章来源的公众号名称或微信号，回车进行搜索\\&quot;]&quot;, &quot;Enter&quot;) # Click text=阮一峰的网络日志 微信号：ruanyf-blog page1.click(&quot;text=订阅号&quot;) time.sleep(3) # Click text=下一页 # 当到最后一页时，没有下一页，退出循环 while True: if page1.is_editable( &quot;#vue_app &gt; div.weui-desktop-link-dialog &gt; div.weui-desktop-dialog__wrp &gt; div &gt; div.weui-desktop-dialog__bd &gt; div.link_dialog_panel &gt; form:nth-child(1) &gt; div:nth-child(4) &gt; div &gt; div &gt; div.weui-desktop-media__list-wrp &gt; div &gt; div&quot;): # 获取网页源码，使用bs4分析，提取链接,返回文章数量 numbers = artical_save(page1, num) if numbers&lt;5: break else: page1.click(&quot;text = 下一页&quot;) time.sleep(random.random()*10) continue 这个函数中需要注意的是：1、大的循环的设定位置在打开超链接之后，点击选择其他公众号之前2、小的翻页循环设定在搜索公众号之后，循环下一页3、判断是否到最后一页，由于我目前没有找到可行的方法，只能使用判断最后一页的文章个数小于五来跳出循环，虽然问题很大，但我就赌他最后一页不是五个QAQ。 3、总结3.1、目前的问题1、最后一页的判断方法有问题2、由于微信公众号的限制，导致翻页过快，系统会封禁一段时间，所以需要将翻页时间设定较长时间，但是经过我的实验，在结束第一个60页的公众号后，到第二个还是会出现系统错误的问题，无法翻页，此问题目前还未解决。3、没有设置自动登录。4、playwright应该有可以直接获取页面信息的方法，但目前我还没有找到，只能通过BeautifulSoup来分析页面. 最后的完整源码在我的GitHub上，欢迎下载。 参考文章:参考链接","link":"/2021/09/01/Playwright-Bs4%E7%88%AC%E5%8F%96%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0%E9%93%BE%E6%8E%A5/"},{"title":"Python-argprase命令行选项、参数和子命令解析","text":"摘要argparse 模块可以让人轻松编写用户友好的命令行接口。程序定义它需要的参数，然后 argparse 将弄清如何从 sys.argv 解析出那些参数。argparse 模块还会自动生成帮助和使用手册，并在用户给程序传入无效参数时报出错误信息。 1、创建一个解析器使用argparse的第一步就是创建一个解析器对象，即ArgumentParser对象，这个对象有多个参数，我们一个一个来讲。 12345678910parser = argparse.ArgumentParser( prog='', # 程序名称 description='', # 在帮助文档前显示的文本 epilog='', # 在帮助文档后显示的文本 add_help=True, # 是否添加帮助选项，即-h，默认True usage='' # 设定usage中显示的文本，默认为：程序名称+-h )# 首先创建一个对象parser = argparse.ArgumentParser(usage=&quot;how to use&quot;，prog='Name',description='Front description',epilog='Back description') 其中各个参数的对应位置如下图：在设置了usage之后，图中对应的就会变为：usage: how to use这些就是基本的常用参数。其他用法请参考官方文档。 2、为解析器添加参数添加参数使用add_argument()方法，我们将逐个讲解，因为这些都比较重要： 12345678910111213ArgumentParser.add_argument( name or flags... # 一个位置参数，或者指定名字的参数 # 即添加的此参数的名字 [, action] # [, nargs] [, const] [, default] [, type] [, choices] [, required] [, help] [, metavar] [, dest]) 2.1、Name or flags首先我们要搞清楚，这个add_argument() 函数到底添加的是什么。为什么第一个参数不带括号，后面的却带。 2.1.1、类比函数传参就像函数传参一样，一个程序不可能只传入一个数据，在函数参数里有两种常用的传参方式：关键字参数，默认参数 1234567891011def printinfo( name, age = 35 )# 这里 name 就是关键字参数# age 自带默认值，就是默认参数def printinfo( name, gander, age = 35 ): print (&quot;名字: &quot;, name) print (&quot;性别: &quot;, gander) print (&quot;年龄: &quot;, age)printinfo( &quot;何小岳&quot; ,&quot;男&quot;)# 名字: 何小岳# 性别: 男# 年龄: 35 但是如果将传入的参数改变位置，那么结果就也会变，这就是位置传参，函数根据输入的数据的位置传入参数名字: 男 性别: 何小岳 年龄: 35而带有默认值的名字就只能通过指定参数的方法传入 123printinfo( age=50, name=&quot;何小岳&quot; )# 名字: 何小岳# 年龄: 50 2.1.2、add_argument()传参因此，与函数传参相同，这里传入的参数也是分为位置传参，和指定参数传入。而与之不同的是：1、函数传参不能限制传入的类型，也就是唯一的限制条件就是默认值2、argparse 传参则可以通过后续的选项来设置限制 name即我们每用 add 一次，就会设置一个参数，例如： 1234567# 针对 add_argument() 的第一个参数 name or flags # 其也是分为两种传参方式，位置，和指定名称parser.add_argument('first')parser.add_argument('second')args = parser.parse_args()print(args.first+args.second) python .\\argparse_learn.py 1 212 这里就将输入的连个字符串连接了起来，是通过位置传参的方式如果输入 -h 就会发现在 usage 中，两个参数的顺序是按添加的顺序显示的usage: My argparse [-h] first second flags这个就是指定名字传参了 12parser.add_argument('--first')parser.add_argument('--second') 如果将上面的两个参数改为这样，再次以同样的方式输入的话就会报错： python .\\argparse_learn.py 1 2usage: My argparse [-h] [–first FIRST] [–second SECOND]My argparse: error: unrecognized arguments: 1 2 所以指定传参只能通过命令行来指定参数传递，比如这样： python .\\argparse_learn.py –first 1 –second 212 但是这样还有个问题，即每次都要输入完整的单词，太长了怎么办 12345parser.add_argument('-f','--first')parser.add_argument('-s','--second')args = parser.parse_args()print(args.first+args.second) python .\\argparse_learn.py -s 2 -f 332 这样再加一个 -f 一位的缩写即可通过短的名字来添加函数，需要特别注意的是：再 print 的时候，需要写全称，因为其中默认的变量名是全称。 -f FIRST, --first FIRST -s SECOND, --second SECOND 2.2 Action这个指的是将命令好参数与动作相关联，默认的是1.store –存储参数的值，上文中可以打印出参数就是因为这个参数2.sotre_const 这个通常和const结合使用，用来存储const命名参数指定的值即在命令行中通过const指定参数的值 12345parser.add_argument('-f','--first',action='store_const',const=&quot;10&quot;)parser.add_argument('-s','--second')args = parser.parse_args()print(args.first+args.second) 123456&gt; python .\\argparse_learn.py -s 2 -f102# 这时如果在指定参数的值就会报错&gt; python .\\argparse_learn.py -s 2 -f 10usage: My argparse [-h] [-f] [-s SECOND]My argparse: error: unrecognized arguments: 10 3.store_truestore_false这两个分别指定参数值为true和false 12345parser.add_argument('-f','--first',action='store_true')print(args.first)------&gt; python .\\argparse_learn.py -s 2False 4.append,储存列表 12345parser.add_argument('-f','--first',action='append')print(args)------&gt; python .\\argparse_learn.py -f 1 -f 2 -f 3Namespace(first=['1', '2', '3'], second=None) 5.append_const,储存const中的值，一般在多个参数需要在同一列表中存储常数时会有用。6.count,计算一个关键字参数出现的次数 parser.add_argument('-f','--first',action='count') python .\\argparse_learn.py -fff3 2.3、Nargs这个参数可以使一个参数，一次添加多个值，变成可迭代对象 123456789101112131415161718N---- #（一个整数），命令中N个参数，聚集形成一个列表例：&gt;&gt;&gt; parser.add_argument('-f', nargs=2)Namespace(first=['a', 'b'])------？---- #这个等于是函数传参中的 *args ，可选传参，另外使用这个即可解决上文中，使用 const 无法在传参的问题parser.add_argument('-f','--first',nargs=&quot;?&quot;,const= 10)&gt; python .\\argparse_learn.py -f 1Namespace(first='1')&gt; python .\\argparse_learn.py -fNamespace(first=10)------* and +---- # 所有参数都聚集到一个列表中,* 和 + 是一个作用，结果也相同parser.add_argument('-f','--first',nargs=&quot;*&quot;/&quot;+&quot;)&gt; python .\\argparse_learn.py -f 1 2 3Namespace(first=['1', '2', '3'])不同的是，当输入为空时，+ 会报错，* 不会 2.4、const通常在store_const, append_const中必须给出参数，其余默认为None。是常数值。 2.5 defult指定在命令行参数未给出的默认值。提供 default=argparse.SUPPRESS 导致命令行参数未出现时没有属性被添加。 2.6、type指定输入类型，通常解析器默认读入的是字符串类型的，如果需要整数等其余类型需要指定type。例如：int,float,ascii,ord等。 2.7、chorice指定参数只能从一个容器中选择，例如： 12345parser.add_argument('-f','--first',choices=[110,120,119])&gt; python .\\argparse_learn.py -f 100usage: My argparse [-h] [-f {110,120,119}] [-s SECOND]My argparse: error: argument -f/--first: invalid choice: '100' (choose from 110, 120, 119) 2.8、required指定参数为必要参数：required=True 2.9、help这是当在命令行加入 -h 参数时，出现在参数后面的解释。 12345678910111213parser.add_argument('-f','--first',choices=[110,120,119],help=&quot;learning&quot;)&gt; python .\\argparse_learn.py -husage: My argparse [-h] [-f {110,120,119}]Front descriptionoptional arguments: -h, --help show this help message and exit -f {110,120,119}, --first {110,120,119} learning #就是这里Back description 2.10、metavar这个参数的意思是，改变的参数显示名字。我们先看默认情况下： 1234567891011121314151617parser.add_argument('-f','--first',help=&quot;learning&quot;)args = parser.parse_args()print(args.first)&gt; python .\\argparse_learn.py -husage: My argparse [-h] [-f FIRST]Front descriptionoptional arguments: -h, --help show this help message and exit -f FIRST, --first FIRST learning# 这里两个参数的别名都是默认的FIRST，所以我们可以通过：# args.first 来访问参数的值&gt; python .\\argparse_learn.py -f 22 如果设定metavar值： 123456parser.add_argument('-f','--first',help=&quot;learning&quot;,,metavar=&quot;fff&quot;)# 这样其访问的名字就会变为fffoptional arguments: -h, --help show this help message and exit -f fff, --first fff learning 但是他只能改变显示名字，无法通过这个来访问元素，还是需要通过原来的值来访问。 12345678&gt; python .\\argparse_learn.py -f 22&gt; python .\\argparse_learn.py -f 2Traceback (most recent call last): File &quot;.\\argparse_learn.py&quot;, line 15, in &lt;module&gt; print(args.fff)AttributeError: 'Namespace' object has no attribute 'fff' 2.11、dest这个dest就是metavar的默认值，所以修改dest即可改变属性的名称。 1234567891011parser.add_argument('-f','--first',help=&quot;learning&quot;,metavar=&quot;fff&quot;,dest=&quot;new_name&quot;)print(args.first)&gt; python .\\argparse_learn.py -f 2AttributeError: 'Namespace' object has no attribute 'first'# 可以看到在我们更改dest后，已经无法通过first来访问属性print(args.new_name)&gt; python .\\argparse_learn.py -f 22# 通过new_name即可访问属性 3、parse_args这是最后一步，这个函数用来解析命令行中的字符串，并将其传入命名空间。 123456789101112# 总结一下# 第一步，创建解析器parser = argparse.ArgumentParser(prog='My argparse',description='Front description',epilog='Back description')# 第二步，添加参数parser.add_argument('-f','--first',help=&quot;learning&quot;,metavar=&quot;fff&quot;,dest=&quot;new_name&quot;)# 第三步，解读命令行args = parser.parse_args()# 最后通过args即可操作输入的参数了# 就像个我上面打印的用法一样，通过属性名，访问属性值 这既是大部分的内容，其余少量的内容，请翻阅官方文档。 参考文章:参考链接","link":"/2021/09/02/Python-argprase%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9%E3%80%81%E5%8F%82%E6%95%B0%E5%92%8C%E5%AD%90%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/"},{"title":"Python自带数据类型之Collections容器数据类型","text":"Python 数据类型学习记录—-collections–容器类型 这个模块实现了特定目标的容器，以提供Python标准内建容器 dict , list , set , 和 tuple 的替代选择。 1、ChainMap对象可将多个字典，或者其他映射组合在一起，创建一个单独的，可更新的视图。如果传入参数为空，则为默认的空字典。 参考文章:参考链接","link":"/2021/09/02/Python%E8%87%AA%E5%B8%A6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8BCollections%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}],"tags":[{"name":"auto","slug":"auto","link":"/tags/auto/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"vpn","slug":"vpn","link":"/tags/vpn/"},{"name":"playwright","slug":"playwright","link":"/tags/playwright/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"automatic","slug":"automatic","link":"/tags/automatic/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Command Control","slug":"Command-Control","link":"/tags/Command-Control/"},{"name":"DataStructure","slug":"DataStructure","link":"/tags/DataStructure/"}],"categories":[{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"markdown","slug":"markdown","link":"/categories/markdown/"},{"name":"tutorial","slug":"tutorial","link":"/categories/tutorial/"},{"name":"learning recording","slug":"learning-recording","link":"/categories/learning-recording/"},{"name":"learning recording","slug":"markdown/learning-recording","link":"/categories/markdown/learning-recording/"},{"name":"python","slug":"learning-recording/python","link":"/categories/learning-recording/python/"},{"name":"argprase","slug":"learning-recording/python/argprase","link":"/categories/learning-recording/python/argprase/"},{"name":"playwright","slug":"learning-recording/python/playwright","link":"/categories/learning-recording/python/playwright/"}]}